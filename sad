-- Função para comprar semente
local function buySeed(seedName)
	local replicatedStorage = game:GetService("ReplicatedStorage")
	local gameEvents = replicatedStorage:WaitForChild("GameEvents")
	local buySeedEvent = gameEvents:WaitForChild("BuySeedStock")

	if buySeedEvent and buySeedEvent.FireServer then
		local args = {seedName}
		buySeedEvent:FireServer(unpack(args))
	else
		warn("Evento BuySeedStock não encontrado ou inválido")
	end
end

-- Carregar biblioteca da interface
local success, Library = pcall(function()
	return loadstring(game:HttpGet("https://raw.githubusercontent.com/bloodball/-back-ups-for-libs/main/wizard"))()
end)

if not success or not Library then
	warn("Falha ao carregar biblioteca wizard")
	return
end

local Window = Library:NewWindow("Credits: TGMANKASKE")
local Section = Window:NewSection("Auto Buy Seeds")

-- Lista de sementes disponíveis
local seedList = {
	"Carrot", "Strawberry", "Bluebarry", "Orange", "Tomato", "Corn", "Daffodil", "Watermelon", "Pumpkin",
	"Apple", "Bamboo", "Coconut", "Cactus", "Dragon Fruit", "Mango", "Grape", "Mushroom", "Pepper",
	"Cacao", "Beanstalk", "Ember lily", "Sugar Apple", "Burning Bud", "Giant Pinecode"
}

-- Variáveis de controle
local selectedSeed = seedList[1] -- Valor inicial
local autoBuyEnabled = false

-- Dropdown de seleção da semente
Section:CreateDropdown("Escolha a Semente", seedList, 1, function(seed)
	selectedSeed = seed
	print("Semente selecionada para auto buy:", selectedSeed)
end)

-- Toggle do Auto Buy
Section:CreateToggle("Auto Buy", function(toggle)
	autoBuyEnabled = toggle
	if autoBuyEnabled then
		print("Auto Buy ativado")
		task.spawn(function()
			while autoBuyEnabled do
				if selectedSeed then
					buySeed(selectedSeed)
				end
				wait(0.2) -- tempo entre compras (ajustável)
			end
		end)
	else
		print("Auto Buy desativado")
	end
end)


-- Auto Collect
local autoCollectEnabled = false
Section:CreateToggle("Auto Collect", function(enabled)
	autoCollectEnabled = enabled
	if autoCollectEnabled then
		print("Auto Collect ativado")

		local Players = game:GetService("Players")
		local player = Players.LocalPlayer
		local TRIGGER_DISTANCE = 10
		local activated = {}

		local function getRoot()
			local character = player.Character or player.CharacterAdded:Wait()
			return character:WaitForChild("HumanoidRootPart")
		end

		local function isPromptClose(prompt, root)
			local part = prompt.Parent
			if part and part:IsA("BasePart") then
				return (part.Position - root.Position).Magnitude <= TRIGGER_DISTANCE
			end
			return false
		end

		local function activatePrompt(prompt)
			if not activated[prompt] and prompt.Enabled and prompt.ActionText == "Collect" then
				activated[prompt] = true
				task.defer(function()
					prompt:InputHoldBegin()
					task.wait(prompt.HoldDuration + 0.05)
					prompt:InputHoldEnd()
					activated[prompt] = nil -- permitir reativar depois
				end)
			end
		end

		local function activateNearbyPrompts(root)
			for _, prompt in ipairs(workspace:GetDescendants()) do
				if prompt:IsA("ProximityPrompt") and prompt.ActionText == "Collect" then
					if isPromptClose(prompt, root) then
						activatePrompt(prompt)
					end
				end
			end
		end

		-- Loop para ativar prompts periodicamente enquanto estiver ligado
		task.spawn(function()
			while autoCollectEnabled do
				local root = getRoot()
				if root then
					activateNearbyPrompts(root)
				end
				task.wait(0.3)
			end
		end)

		-- Conectar novo prompt adicionado ao workspace
		workspace.DescendantAdded:Connect(function(descendant)
			if autoCollectEnabled and descendant:IsA("ProximityPrompt") and descendant.ActionText == "Collect" then
				local root = getRoot()
				if root and isPromptClose(descendant, root) then
					activatePrompt(descendant)
				end
			end
		end)

	else
		print("Auto Collect desativado")
	end
end)
